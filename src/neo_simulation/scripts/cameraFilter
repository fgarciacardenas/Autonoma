#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#   Este nodo se suscribe a una imagen de ROS, la convierte en una matriz de
#   OpenCV y la muestra en pantalla
#

import rospy
import cv2
import numpy as np
from sensor_msgs.msg import Image
from cv_bridge import CvBridge

def is_contour_good(c):
    # approximate the contour
    peri = cv2.arcLength(c, True)
    approx = cv2.approxPolyDP(c, 0.1 * peri, True)
    # the contour is 'good' if it is a rectangle
    return len(approx) == 4

class Cam(object):
    def __init__(self, topic_name="camera/rgb/image_raw"):
        self.bridge = CvBridge()
        self.image = np.zeros((10,10))
        isub = rospy.Subscriber(topic_name, Image, self.image_callback)

    def image_callback(self, img):
        self.image = self.bridge.imgmsg_to_cv2(img, "bgr8")

    def get_image(self):
        return self.image

# Inicializar el nodo de ROS
rospy.init_node('camera_node')

# Objeto que se suscribe al tópico de la cámara
topic_name = "/camera/rgb/image_raw"
cam = Cam(topic_name)

# Tópico para publicar una imagen de salida
topic_pub = 'image_out'
pubimg = rospy.Publisher(topic_pub, Image, queue_size=10)

# Morph
kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5,5))

# Frecuencia del bucle principal
freq = 10
rate = rospy.Rate(freq)
flag = False
# Bucle principal
while not rospy.is_shutdown():
    # Obtener la imagen del tópico de ROS en formato de OpenCV
    I = cam.get_image()
    if flag:
        inputImageGray = cv2.cvtColor(I, cv2.COLOR_BGR2GRAY)

        blur = cv2.GaussianBlur(inputImageGray,(5,5),0)

        # Find Sobel derivatives in x and y direction. Compute magnitude with equal weight for both direction.
        Dx = cv2.Sobel(blur,cv2.CV_8UC1,1,0)
        Dy = cv2.Sobel(blur,cv2.CV_8UC1,0,1)
        M = cv2.addWeighted(Dx, 1, Dy,1,0)
        ret, edgesharp = cv2.threshold(M,10,255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)

        horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5,1))
        vertical_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1,5))

        horizontal = cv2.morphologyEx(edgesharp, cv2.MORPH_OPEN, horizontal_kernel, iterations=1)
        vertical = cv2.morphologyEx(edgesharp, cv2.MORPH_OPEN, vertical_kernel, iterations=1)
        diff = edgesharp - horizontal - vertical

        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(20,20))
        closed = cv2.morphologyEx(diff, cv2.MORPH_CLOSE, kernel, iterations=1)
        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(15,15))
        opened = cv2.morphologyEx(closed, cv2.MORPH_OPEN, kernel, iterations=1)


        cnts = cv2.findContours(opened, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
        cnts = cnts[0] if len(cnts) == 2 else cnts[1]
        mask = np.ones(opened.shape[:2], dtype="uint8") * 255
        for c in cnts:
            # if the contour is good, draw it on the mask
            if is_contour_good(c):
                cv2.drawContours(mask, [c], -1, 0, -1)

        mask = cv2.bitwise_not(mask)
        # Mostrar la imagen
        cv2.imshow("Imagen", mask)
    # Esperar al bucle para actualizar
    cv2.waitKey(1)
    # Opcional: publicar la imagen de salida como tópico de ROS
    #pubimg.publish(cam.bridge.cv2_to_imgmsg(I))
    flag = True
    rate.sleep()

cv2.destroyAllWindows()