#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#   Este nodo se suscribe a una imagen de ROS, la convierte en una matriz de
#   OpenCV y la muestra en pantalla
#

import rospy
import cv2
import numpy as np
from sensor_msgs.msg import Image
from cv_bridge import CvBridge

def is_contour_good(c):
    # approximate the contour
    peri = cv2.arcLength(c, True)
    approx = cv2.approxPolyDP(c, 0.1 * peri, True)
    # the contour is 'good' if it is a rectangle
    return len(approx) == 4

class Cam(object):
    def __init__(self, topic_name="camera/rgb/image_raw"):
        self.bridge = CvBridge()
        self.image = np.zeros((10,10))
        isub = rospy.Subscriber(topic_name, Image, self.image_callback)

    def image_callback(self, img):
        self.image = self.bridge.imgmsg_to_cv2(img, "bgr8")

    def get_image(self):
        return self.image

# Inicializar el nodo de ROS
rospy.init_node('camera_node')

# Objeto que se suscribe al tópico de la cámara
topic_name = "/camera/rgb/image_raw"
cam = Cam(topic_name)

# Tópico para publicar una imagen de salida
topic_pub = 'image_out'
pubimg = rospy.Publisher(topic_pub, Image, queue_size=10)

# Morph
kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5,5))

# Frecuencia del bucle principal
freq = 10
rate = rospy.Rate(freq)
flag = False
# Bucle principal
while not rospy.is_shutdown():
    # Obtener la imagen del tópico de ROS en formato de OpenCV
    I = cam.get_image()
    if flag:
        # Convertir BGR a HSV
        Ihsv = cv2.cvtColor(I, cv2.COLOR_BGR2HSV)
        # red lower mask (0-10)
        lower_red = np.array([0,50,50])
        upper_red = np.array([5,255,255])
        mask0 = cv2.inRange(Ihsv, lower_red, upper_red)

        # red upper mask (170-180)
        lower_red = np.array([175,50,50])
        upper_red = np.array([180,255,255])
        mask1 = cv2.inRange(Ihsv, lower_red, upper_red)

        # join red masks
        sodaMask = mask0+mask1
        sodaMask = cv2.morphologyEx(sodaMask, cv2.MORPH_OPEN, kernel)
        #sodaMask = cv2.dilate(sodaMask, kernel, iterations=2)
        sodaMask = cv2.morphologyEx(sodaMask, cv2.MORPH_OPEN, kernel)
        sodaMask = cv2.dilate(sodaMask, kernel, iterations=2)
        
        # blue mask
        lower_blue = np.array([100,140,0])
        upper_blue = np.array([140,255,180])
        mask2 = cv2.inRange(Ihsv, lower_blue, upper_blue)
        # gold mask
        lower_yellow = np.array([15,50,50])
        upper_yellow = np.array([25,255,255])
        mask3 = cv2.inRange(Ihsv, lower_yellow, upper_yellow)

        # join beer colors masks
        beerMask = mask2+mask3
        beerMask = cv2.morphologyEx(beerMask, cv2.MORPH_CLOSE, kernel)
        beerMask = cv2.dilate(beerMask, kernel, iterations=2)

        # Convert image to HSV color space. Increase V by a factor of 2 in order to have more visible things
        H,S,V = Ihsv[:,:,0], Ihsv[:,:,1], Ihsv[:,:,2]
        V = V * 2

        hsv_image = cv2.merge([H,S,V])
        image = cv2.cvtColor(hsv_image, cv2.COLOR_HSV2RGB)
        image = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)

        # Find Sobel derivatives in x and y direction. Compute magnitude with equal weight for both direction.
        Dx = cv2.Sobel(image,cv2.CV_8UC1,1,0)
        Dy = cv2.Sobel(image,cv2.CV_8UC1,0,1)
        M = cv2.addWeighted(Dx, 1, Dy,1,0)

        # Threshold your image using Otsu method
        ret, binary = cv2.threshold(M,10,255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)

        # Apply Closing
        binary = binary.astype(np.uint8)
        binary = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5)))

        # Apply Erosion to get rid of extra lines
        kernel = np.ones((2,2),np.uint8)
        erosion = cv2.erode(binary,kernel,iterations = 1)        

        # Find contours
        cnts1 = cv2.findContours(sodaMask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        cnts1 = cnts1[0] if len(cnts1) == 2 else cnts1[1]
        cnts2 = cv2.findContours(beerMask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        cnts2 = cnts2[0] if len(cnts2) == 2 else cnts2[1]
        cnts = zip(cnts1, cnts2)
        # Iterate thorugh contours and filter for ROI
        for c1, c2 in cnts:
            x1,y1,w1,h1 = cv2.boundingRect(c1)
            x2,y2,w2,h2 = cv2.boundingRect(c2)
            if w1 < h1:
                cv2.rectangle(I, (x1, y1), (x1 + w1, y1 + h1), (36,255,12), 2)
                cv2.putText(I, 'Coke', (x1, y1-10), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (36,255,12),2)
            if w2 < h2:
                cv2.rectangle(I, (x2, y2), (x2 + w2, y2 + h2), (36,255,12), 2)
                cv2.putText(I, 'Beer', (x2, y2-10), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (36,255,12),2)
        # Mostrar la imagen
        cv2.imshow("Imagen", erosion)
    # Esperar al bucle para actualizar
    cv2.waitKey(1)
    # Opcional: publicar la imagen de salida como tópico de ROS
    #pubimg.publish(cam.bridge.cv2_to_imgmsg(I))
    flag = True
    rate.sleep()

cv2.destroyAllWindows()